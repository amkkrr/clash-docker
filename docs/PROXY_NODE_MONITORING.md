# ğŸŒ ä»£ç†èŠ‚ç‚¹ç›‘æ§ä¸å¯ç”¨æ€§çœ‹æ¿

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æè¿°äº†ä¸º Clash Docker é¡¹ç›®å®ç°ä»£ç†èŠ‚ç‚¹çŠ¶æ€ç›‘æ§å’Œå¯ç”¨æ€§çœ‹æ¿çš„å®Œæ•´è§£å†³æ–¹æ¡ˆï¼ŒåŒ…æ‹¬å¤šåè®®èŠ‚ç‚¹æ£€æµ‹ã€æ€§èƒ½ç›‘æ§ã€å®æ—¶çœ‹æ¿å’Œæ™ºèƒ½å‘Šè­¦ç³»ç»Ÿã€‚

## ğŸ¯ ç›®æ ‡å—ä¼—

- **è¿ç»´å·¥ç¨‹å¸ˆ**: ç›‘æ§ä»£ç†èŠ‚ç‚¹å¥åº·çŠ¶æ€
- **å¼€å‘å·¥ç¨‹å¸ˆ**: é›†æˆèŠ‚ç‚¹ç›‘æ§åŠŸèƒ½
- **æœ€ç»ˆç”¨æˆ·**: æŸ¥çœ‹èŠ‚ç‚¹å¯ç”¨æ€§å’Œæ€§èƒ½æŒ‡æ ‡

## ğŸ“š å†…å®¹ç›®å½•

1. [åŠŸèƒ½ç‰¹æ€§](#-åŠŸèƒ½ç‰¹æ€§)
2. [æŠ€æœ¯æ¶æ„](#-æŠ€æœ¯æ¶æ„)
3. [ç›‘æ§æŒ‡æ ‡](#-ç›‘æ§æŒ‡æ ‡)
4. [å®ç°æ–¹æ¡ˆ](#-å®ç°æ–¹æ¡ˆ)
5. [çœ‹æ¿è®¾è®¡](#-çœ‹æ¿è®¾è®¡)
6. [éƒ¨ç½²æŒ‡å—](#-éƒ¨ç½²æŒ‡å—)
7. [APIæ¥å£](#-apiæ¥å£)
8. [æ€§èƒ½ä¼˜åŒ–](#-æ€§èƒ½ä¼˜åŒ–)

---

## âœ¨ **åŠŸèƒ½ç‰¹æ€§**

### **æ ¸å¿ƒç›‘æ§åŠŸèƒ½**
- ğŸ” **å¤šåè®®æ”¯æŒ**: Hysteria2ã€Shadowsocksã€VMessã€VLESSã€Trojanã€SOCKS5
- âš¡ **å®æ—¶æ£€æµ‹**: 30ç§’-5åˆ†é’Ÿå¯é…ç½®æ£€æµ‹é—´éš”
- ğŸ“Š **æ€§èƒ½æŒ‡æ ‡**: å»¶è¿Ÿã€é€Ÿåº¦ã€å¯ç”¨ç‡ã€è¿æ¥æˆåŠŸç‡
- ğŸŒ **åœ°ç†ä¿¡æ¯**: è‡ªåŠ¨è¯†åˆ«èŠ‚ç‚¹åœ°ç†ä½ç½®å’ŒISPä¿¡æ¯
- ğŸ“ˆ **å†å²æ•°æ®**: 30å¤©æ€§èƒ½å†å²æ•°æ®å­˜å‚¨å’Œåˆ†æ

### **å¯è§†åŒ–çœ‹æ¿**
- ğŸ¨ **å®æ—¶çŠ¶æ€**: èŠ‚ç‚¹çŠ¶æ€å®æ—¶æ›´æ–°ï¼Œç»¿/é»„/çº¢çŠ¶æ€æŒ‡ç¤º
- ğŸ“Š **æ€§èƒ½å›¾è¡¨**: å»¶è¿Ÿè¶‹åŠ¿ã€é€Ÿåº¦æµ‹è¯•ã€å¯ç”¨ç‡ç»Ÿè®¡
- ğŸŒ **åœ°å›¾è§†å›¾**: å…¨çƒèŠ‚ç‚¹åˆ†å¸ƒåœ°å›¾
- ğŸ“± **å“åº”å¼è®¾è®¡**: æ”¯æŒæ¡Œé¢å’Œç§»åŠ¨è®¾å¤‡è®¿é—®

### **æ™ºèƒ½å‘Šè­¦**
- ğŸš¨ **æ•…éšœå‘Šè­¦**: èŠ‚ç‚¹ç¦»çº¿ã€è¶…æ—¶ã€æ€§èƒ½ä¸‹é™è‡ªåŠ¨é€šçŸ¥
- ğŸ”„ **æ¢å¤æ£€æµ‹**: èŠ‚ç‚¹æ¢å¤åè‡ªåŠ¨æ ‡è®°å¹¶é€šçŸ¥
- ğŸ“§ **å¤šç§é€šçŸ¥**: é‚®ä»¶ã€Webhookã€Telegram Bot
- â° **å‘Šè­¦æŠ‘åˆ¶**: é¿å…é‡å¤å‘Šè­¦ï¼Œæ”¯æŒå‘Šè­¦é™é»˜æœŸ

---

## ğŸ—ï¸ **æŠ€æœ¯æ¶æ„**

### **æ•´ä½“æ¶æ„å›¾**

```mermaid
graph TB
    subgraph "é…ç½®ç®¡ç†"
        A[.envé…ç½®è§£æ] --> B[èŠ‚ç‚¹é…ç½®æå–]
        B --> C[ç›‘æ§ä»»åŠ¡ç”Ÿæˆ]
    end
    
    subgraph "ç›‘æ§å¼•æ“"
        D[è°ƒåº¦å™¨] --> E[è¿æ¥æµ‹è¯•å™¨]
        E --> F[å»¶è¿Ÿæµ‹è¯•å™¨]
        F --> G[é€Ÿåº¦æµ‹è¯•å™¨]
        G --> H[åœ°ç†ä¿¡æ¯æ£€æµ‹]
    end
    
    subgraph "æ•°æ®å­˜å‚¨"
        I[Redisç¼“å­˜] --> J[InfluxDBæ—¶åºæ•°æ®]
        J --> K[SQLiteé…ç½®æ•°æ®]
    end
    
    subgraph "Webç•Œé¢"
        L[Reactå‰ç«¯] --> M[å®æ—¶çœ‹æ¿]
        M --> N[æ€§èƒ½å›¾è¡¨]
        N --> O[å‘Šè­¦ä¸­å¿ƒ]
    end
    
    subgraph "å‘Šè­¦ç³»ç»Ÿ"
        P[è§„åˆ™å¼•æ“] --> Q[é€šçŸ¥æœåŠ¡]
        Q --> R[é‚®ä»¶/Webhook/Bot]
    end
    
    C --> D
    H --> I
    I --> L
    I --> P
```

### **æ ¸å¿ƒç»„ä»¶**

#### **1. èŠ‚ç‚¹å‘ç°å™¨ (Node Discovery)**
```python
class NodeDiscovery:
    """ä»ç¯å¢ƒå˜é‡è‡ªåŠ¨å‘ç°ä»£ç†èŠ‚ç‚¹"""
    
    def __init__(self, env_file=".env"):
        self.env_file = env_file
        self.supported_protocols = {
            'hysteria2': ['HYSTERIA2_SERVER', 'HYSTERIA2_PORTS', 'HYSTERIA2_PASSWORD'],
            'shadowsocks': ['SS_SERVER', 'SS_PORT', 'SS_PASSWORD', 'SS_CIPHER'],
            'vmess': ['VMESS_SERVER', 'VMESS_PORT', 'VMESS_UUID', 'VMESS_WS_PATH'],
            'vless': ['VLESS_SERVER', 'VLESS_PORT', 'VLESS_UUID', 'VLESS_WS_PATH'],
            'trojan': ['TROJAN_SERVER', 'TROJAN_PORT', 'TROJAN_PASSWORD']
        }
    
    def discover_nodes(self) -> List[ProxyNode]:
        """å‘ç°æ‰€æœ‰é…ç½®çš„ä»£ç†èŠ‚ç‚¹"""
        nodes = []
        env_vars = self._parse_env_file()
        
        for protocol, required_vars in self.supported_protocols.items():
            nodes.extend(self._extract_nodes_by_protocol(env_vars, protocol))
        
        return nodes
    
    def _extract_nodes_by_protocol(self, env_vars: dict, protocol: str) -> List[ProxyNode]:
        """æŒ‰åè®®æå–èŠ‚ç‚¹é…ç½®"""
        nodes = []
        # æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…çš„èŠ‚ç‚¹å‰ç¼€
        prefixes = self._find_node_prefixes(env_vars, protocol)
        
        for prefix in prefixes:
            node_config = self._build_node_config(env_vars, prefix, protocol)
            if self._validate_node_config(node_config):
                nodes.append(ProxyNode(
                    name=prefix,
                    protocol=protocol,
                    config=node_config
                ))
        
        return nodes
```

#### **2. çœŸå®ä»£ç†å¯ç”¨æ€§æµ‹è¯•å™¨ (Real Proxy Availability Tester)**
```python
class RealProxyTester:
    """çœŸå®ä»£ç†æœåŠ¡å¯ç”¨æ€§æµ‹è¯• - ä¸ä»…ä»…æ˜¯è¿é€šæ€§"""
    
    def __init__(self):
        self.test_targets = [
            "http://httpbin.org/ip",          # è·å–å‡ºå£IP
            "https://api.github.com/zen",     # HTTPSæµ‹è¯•
            "http://detectportal.firefox.com/success.txt"  # è½»é‡æ£€æµ‹
        ]
        self.timeout = 15
        self.user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    
    async def test_proxy_availability(self, node: ProxyNode) -> ProxyAvailabilityResult:
        """çœŸå®ä»£ç†æœåŠ¡å¯ç”¨æ€§æµ‹è¯• - å¤šå±‚éªŒè¯"""
        start_time = time.time()
        
        try:
            # ç¬¬ä¸€æ­¥: åŸºç¡€è¿é€šæ€§æ£€æŸ¥
            basic_check = await self._basic_connectivity_check(node)
            if not basic_check.success:
                return ProxyAvailabilityResult(
                    node_name=node.name,
                    overall_status='offline',
                    error=basic_check.error,
                    timestamp=time.time(),
                    test_details={'basic_check': basic_check}
                )
            
            # ç¬¬äºŒæ­¥: åè®®ç‰¹å®šæµ‹è¯•
            protocol_test = await self._protocol_specific_test(node)
            if not protocol_test.success:
                return ProxyAvailabilityResult(
                    node_name=node.name,
                    overall_status='protocol_error',
                    error=protocol_test.error,
                    timestamp=time.time(),
                    test_details={'protocol_test': protocol_test}
                )
            
            # ç¬¬ä¸‰æ­¥: çœŸå®HTTP/HTTPSè¯·æ±‚æµ‹è¯•
            http_tests = await self._real_traffic_test(node)
            
            # ç¬¬å››æ­¥: å‡ºå£IPæ£€æµ‹å’Œåœ°ç†ä½ç½®éªŒè¯
            exit_ip_test = await self._exit_ip_verification(node)
            
            # ç»¼åˆè¯„ä¼°
            overall_status = self._evaluate_overall_status(
                basic_check, protocol_test, http_tests, exit_ip_test
            )
            
            return ProxyAvailabilityResult(
                node_name=node.name,
                overall_status=overall_status,
                latency=protocol_test.latency,
                exit_ip=exit_ip_test.exit_ip,
                geographic_info=exit_ip_test.geo_info,
                timestamp=time.time(),
                test_duration=time.time() - start_time,
                test_details={
                    'basic_check': basic_check,
                    'protocol_test': protocol_test,
                    'http_tests': http_tests,
                    'exit_ip_test': exit_ip_test
                }
            )
            
        except Exception as e:
            return ProxyAvailabilityResult(
                node_name=node.name,
                overall_status='error',
                error=str(e),
                timestamp=time.time(),
                test_duration=time.time() - start_time
            )
    
    async def _basic_connectivity_check(self, node: ProxyNode) -> BasicCheckResult:
        """åŸºç¡€è¿é€šæ€§æ£€æŸ¥ - ç«¯å£å’ŒæœåŠ¡å“åº”"""
        try:
            # TCPè¿æ¥æ£€æŸ¥
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(node.config['server'], node.config['port']),
                timeout=5
            )
            writer.close()
            await writer.wait_closed()
            
            return BasicCheckResult(success=True, message="TCPè¿æ¥æˆåŠŸ")
            
        except asyncio.TimeoutError:
            return BasicCheckResult(success=False, error="è¿æ¥è¶…æ—¶")
        except ConnectionRefusedError:
            return BasicCheckResult(success=False, error="è¿æ¥è¢«æ‹’ç»")
        except Exception as e:
            return BasicCheckResult(success=False, error=f"è¿æ¥é”™è¯¯: {str(e)}")
    
    async def _protocol_specific_test(self, node: ProxyNode) -> ProtocolTestResult:
        """åè®®ç‰¹å®šçš„è®¤è¯å’Œæ¡æ‰‹æµ‹è¯•"""
        start_time = time.time()
        
        try:
            if node.protocol == 'shadowsocks':
                return await self._test_shadowsocks_auth(node, start_time)
            elif node.protocol == 'hysteria2':
                return await self._test_hysteria2_auth(node, start_time)
            elif node.protocol in ['vmess', 'vless']:
                return await self._test_v2ray_auth(node, start_time)
            elif node.protocol == 'trojan':
                return await self._test_trojan_auth(node, start_time)
            else:
                return ProtocolTestResult(
                    success=False, 
                    error=f"ä¸æ”¯æŒçš„åè®®: {node.protocol}"
                )
                
        except Exception as e:
            return ProtocolTestResult(
                success=False,
                error=f"åè®®æµ‹è¯•å¤±è´¥: {str(e)}",
                latency=(time.time() - start_time) * 1000
            )
    
    async def _real_traffic_test(self, node: ProxyNode) -> List[HttpTestResult]:
        """çœŸå®HTTP/HTTPSæµé‡æµ‹è¯•"""
        results = []
        
        # åˆ›å»ºä»£ç†é…ç½®
        proxy_config = self._create_proxy_config(node)
        
        for target_url in self.test_targets:
            try:
                start_time = time.time()
                
                # ä½¿ç”¨ä»£ç†å‘é€HTTPè¯·æ±‚
                async with aiohttp.ClientSession(
                    connector=aiohttp.ProxyConnector.from_url(proxy_config),
                    timeout=aiohttp.ClientTimeout(total=self.timeout),
                    headers={'User-Agent': self.user_agent}
                ) as session:
                    async with session.get(target_url) as response:
                        content = await response.text()
                        latency = (time.time() - start_time) * 1000
                        
                        results.append(HttpTestResult(
                            url=target_url,
                            success=response.status == 200,
                            status_code=response.status,
                            latency=latency,
                            content_length=len(content),
                            response_content=content[:200]  # å‰200å­—ç¬¦
                        ))
                        
            except asyncio.TimeoutError:
                results.append(HttpTestResult(
                    url=target_url,
                    success=False,
                    error="è¯·æ±‚è¶…æ—¶"
                ))
            except Exception as e:
                results.append(HttpTestResult(
                    url=target_url,
                    success=False,
                    error=str(e)
                ))
        
        return results
    
    async def _exit_ip_verification(self, node: ProxyNode) -> ExitIpTestResult:
        """å‡ºå£IPæ£€æµ‹å’Œåœ°ç†ä½ç½®éªŒè¯"""
        try:
            proxy_config = self._create_proxy_config(node)
            
            async with aiohttp.ClientSession(
                connector=aiohttp.ProxyConnector.from_url(proxy_config),
                timeout=aiohttp.ClientTimeout(total=10)
            ) as session:
                # è·å–å‡ºå£IP
                async with session.get("http://httpbin.org/ip") as response:
                    if response.status == 200:
                        data = await response.json()
                        exit_ip = data.get('origin', '').split(',')[0].strip()
                        
                        # åœ°ç†ä½ç½®æ£€æµ‹
                        geo_info = await self._get_geographic_info(exit_ip)
                        
                        # éªŒè¯IPæ˜¯å¦ç¬¦åˆé¢„æœŸåœ°åŒº
                        region_match = self._verify_expected_region(node, geo_info)
                        
                        return ExitIpTestResult(
                            success=True,
                            exit_ip=exit_ip,
                            geo_info=geo_info,
                            region_match=region_match
                        )
                    else:
                        return ExitIpTestResult(
                            success=False,
                            error=f"IPæ£€æµ‹å¤±è´¥: HTTP {response.status}"
                        )
                        
        except Exception as e:
            return ExitIpTestResult(
                success=False,
                error=f"å‡ºå£IPæ£€æµ‹å¤±è´¥: {str(e)}"
            )
    
    def _create_proxy_config(self, node: ProxyNode) -> str:
        """æ ¹æ®åè®®åˆ›å»ºä»£ç†é…ç½®URL"""
        config = node.config
        
        if node.protocol == 'shadowsocks':
            # ss://method:password@server:port
            auth = f"{config['cipher']}:{config['password']}"
            auth_b64 = base64.b64encode(auth.encode()).decode()
            return f"ss://{auth_b64}@{config['server']}:{config['port']}"
            
        elif node.protocol == 'http':
            return f"http://{config['server']}:{config['port']}"
            
        elif node.protocol == 'socks5':
            if 'username' in config:
                return f"socks5://{config['username']}:{config['password']}@{config['server']}:{config['port']}"
            else:
                return f"socks5://{config['server']}:{config['port']}"
        
        # å¯¹äºå¤æ‚åè®®ï¼Œéœ€è¦å¯åŠ¨ä¸´æ—¶ä»£ç†è¿›ç¨‹
        else:
            return self._create_temp_proxy_process(node)
    
    def _evaluate_overall_status(self, basic_check, protocol_test, http_tests, exit_ip_test) -> str:
        """ç»¼åˆè¯„ä¼°ä»£ç†çŠ¶æ€"""
        if not basic_check.success:
            return 'offline'
        
        if not protocol_test.success:
            return 'protocol_error'
        
        successful_http_tests = sum(1 for test in http_tests if test.success)
        http_success_rate = successful_http_tests / len(http_tests)
        
        if http_success_rate == 0:
            return 'traffic_blocked'
        elif http_success_rate < 0.5:
            return 'unstable'
        elif not exit_ip_test.success:
            return 'ip_detection_failed'
        elif exit_ip_test.region_match is False:
            return 'wrong_region'
        else:
            return 'fully_available'
    
    async def _test_shadowsocks(self, node: ProxyNode) -> TestResult:
        """Shadowsocksè¿æ¥æµ‹è¯•"""
        import shadowsocks_client
        
        client = shadowsocks_client.SSClient(
            server=node.config['server'],
            port=node.config['port'],
            password=node.config['password'],
            cipher=node.config['cipher']
        )
        
        # æµ‹è¯•HTTPè¯·æ±‚
        test_url = "http://httpbin.org/ip"
        start_time = time.time()
        
        try:
            response = await client.get(test_url, timeout=10)
            latency = (time.time() - start_time) * 1000
            
            return TestResult(
                success=response.status_code == 200,
                latency=latency,
                response_data=response.json()
            )
        except Exception as e:
            return TestResult(success=False, error=str(e))
```

#### **3. æ€§èƒ½æµ‹è¯•å™¨ (Performance Tester)**
```python
class PerformanceTester:
    """ä»£ç†æ€§èƒ½æµ‹è¯•"""
    
    async def test_performance(self, node: ProxyNode) -> PerformanceResult:
        """ç»¼åˆæ€§èƒ½æµ‹è¯•"""
        results = {
            'latency': await self._test_latency(node),
            'speed': await self._test_speed(node),
            'stability': await self._test_stability(node)
        }
        
        return PerformanceResult(
            node_name=node.name,
            **results
        )
    
    async def _test_latency(self, node: ProxyNode, count=5) -> LatencyResult:
        """å»¶è¿Ÿæµ‹è¯• - å¤šæ¬¡pingå–å¹³å‡å€¼"""
        latencies = []
        
        for _ in range(count):
            start_time = time.time()
            try:
                # é€šè¿‡ä»£ç†è®¿é—®å¿«é€Ÿå“åº”çš„API
                response = await self._proxy_request(
                    node, "http://httpbin.org/get", timeout=5
                )
                if response.status_code == 200:
                    latency = (time.time() - start_time) * 1000
                    latencies.append(latency)
            except:
                continue
            
            await asyncio.sleep(0.5)  # é¿å…è¿‡äºé¢‘ç¹
        
        if latencies:
            return LatencyResult(
                min=min(latencies),
                max=max(latencies),
                avg=sum(latencies) / len(latencies),
                success_rate=len(latencies) / count * 100
            )
        else:
            return LatencyResult(error="æ‰€æœ‰å»¶è¿Ÿæµ‹è¯•å¤±è´¥")
    
    async def _test_speed(self, node: ProxyNode) -> SpeedResult:
        """é€Ÿåº¦æµ‹è¯• - ä¸‹è½½æµ‹è¯•æ–‡ä»¶"""
        test_files = [
            ("1MB", "http://speedtest.ftp.otenet.gr/files/test1Mb.db"),
            ("10MB", "http://speedtest.ftp.otenet.gr/files/test10Mb.db")
        ]
        
        speeds = {}
        
        for size, url in test_files:
            try:
                start_time = time.time()
                response = await self._proxy_request(
                    node, url, timeout=30, stream=True
                )
                
                downloaded = 0
                async for chunk in response.iter_content(chunk_size=8192):
                    downloaded += len(chunk)
                
                duration = time.time() - start_time
                speed_mbps = (downloaded / 1024 / 1024) / duration
                speeds[size] = speed_mbps
                
            except Exception as e:
                speeds[size] = f"é”™è¯¯: {str(e)}"
        
        return SpeedResult(speeds=speeds)
```

---

## âš ï¸ **ä»£ç†å¯ç”¨æ€§æ£€æµ‹çš„æŠ€æœ¯å¤æ‚æ€§åˆ†æ**

### **ä¸ºä»€ä¹ˆç®€å•çš„è¿é€šæ€§æ£€æµ‹æ˜¯ä¸å¤Ÿçš„**

```mermaid
graph TD
    A[ç®€å•Pingæµ‹è¯•] --> B[âŒ åªæ£€æµ‹ç½‘ç»œè¿é€šæ€§]
    A --> C[âŒ æ— æ³•éªŒè¯ä»£ç†è®¤è¯]
    A --> D[âŒ ä¸æ£€æµ‹å®é™…æµé‡ä¼ è¾“]
    
    E[çœŸå®ä»£ç†å¯ç”¨æ€§] --> F[âœ… åè®®è®¤è¯æˆåŠŸ]
    E --> G[âœ… å®é™…HTTPæµé‡é€šè¿‡]
    E --> H[âœ… å‡ºå£IPåœ°ç†ä½ç½®æ­£ç¡®]
    E --> I[âœ… æ— æµé‡é™åˆ¶/å°é”]
    
    style B fill:#ffebee
    style C fill:#ffebee  
    style D fill:#ffebee
    style F fill:#e8f5e8
    style G fill:#e8f5e8
    style H fill:#e8f5e8
    style I fill:#e8f5e8
```

### **åè®®ç‰¹å®šçš„æŠ€æœ¯æŒ‘æˆ˜**

| åè®®ç±»å‹ | ä¸»è¦æŠ€æœ¯æŒ‘æˆ˜ | æ£€æµ‹å¤æ‚åº¦ | å®ç°éš¾ç‚¹ |
|----------|--------------|------------|----------|
| **Shadowsocks** | åŠ å¯†è®¤è¯ã€å¯†ç éªŒè¯ | â­â­â­ | éœ€è¦å®ç°åŠ å¯†æ¡æ‰‹ |
| **VMess** | UUIDè®¤è¯ã€WebSocketå‡çº§ã€æ—¶é—´åŒæ­¥ | â­â­â­â­ | åè®®å¤æ‚ï¼Œæ¡æ‰‹æ­¥éª¤å¤š |
| **VLESS** | UUIDè®¤è¯ã€TLSéªŒè¯ã€WebSocket | â­â­â­â­ | ç±»ä¼¼VMessä½†æ›´ä¸¥æ ¼ |
| **Hysteria2** | QUICåè®®ã€å¿«é€Ÿæ¡æ‰‹ã€ç«¯å£èŒƒå›´ | â­â­â­â­â­ | åŸºäºUDPï¼ŒçŠ¶æ€è·Ÿè¸ªå¤æ‚ |
| **Trojan** | TLSä¼ªè£…ã€è¯ä¹¦éªŒè¯ã€å¯†ç è®¤è¯ | â­â­â­â­ | éœ€è¦å®Œæ•´TLSæ¡æ‰‹ |

### **å®é™…ç½‘ç»œç¯å¢ƒçš„æŒ‘æˆ˜**

#### **1. ç½‘ç»œå±‚é¢å¹²æ‰°**
```python
network_challenges = {
    "DNSå¹²æ‰°": [
        "DNSæ±¡æŸ“å¯¼è‡´è§£æé”™è¯¯",
        "DNSåŠ«æŒåˆ°é”™è¯¯IP",  
        "DNSæŸ¥è¯¢è¢«é˜»æ–­"
    ],
    "DPIæ£€æµ‹": [
        "æ·±åŒ…æ£€æµ‹è¯†åˆ«ä»£ç†æµé‡",
        "åè®®ç‰¹å¾è¢«è¿è¥å•†è¯†åˆ«",
        "æµé‡æ¨¡å¼åˆ†æ"
    ],
    "QoSé™åˆ¶": [
        "ä»£ç†æµé‡è¢«é™é€Ÿ",
        "ç‰¹å®šç«¯å£è¢«é™åˆ¶",
        "é«˜å»¶è¿Ÿ/ä¸¢åŒ…"
    ]
}
```

#### **2. æœåŠ¡ç«¯çŠ¶æ€é—®é¢˜**
```python
server_side_issues = {
    "è®¤è¯é—®é¢˜": [
        "å¯†ç è¿‡æœŸ/æ›´æ”¹",
        "UUIDå¤±æ•ˆ",
        "æ—¶é—´ä¸åŒæ­¥å¯¼è‡´è®¤è¯å¤±è´¥"
    ],
    "èµ„æºé™åˆ¶": [
        "æµé‡é…é¢è€—å°½",
        "å¹¶å‘è¿æ¥æ•°é™åˆ¶",
        "æœåŠ¡å™¨è¿‡è½½"
    ],
    "åœ°ç†é™åˆ¶": [
        "IPåœ°å€è¢«ç›®æ ‡ç½‘ç«™å°ç¦",
        "åœ°ç†ä½ç½®ä¸ç¬¦åˆè¦æ±‚",
        "ç‰¹å®šåœ°åŒºè®¿é—®é™åˆ¶"
    ]
}
```

### **å¤šå±‚æ£€æµ‹æ–¹æ¡ˆè®¾è®¡**

æˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆé‡‡ç”¨**4å±‚é€’è¿›å¼æ£€æµ‹**ï¼š

#### **ç¬¬1å±‚: åŸºç¡€è¿é€šæ€§** (ç®€å•ä½†å¿…è¦)
- TCPè¿æ¥åˆ°ä»£ç†æœåŠ¡å™¨
- ç«¯å£å¯è¾¾æ€§æ£€æŸ¥
- åŸºç¡€ç½‘ç»œå»¶è¿Ÿæµ‹é‡

#### **ç¬¬2å±‚: åè®®è®¤è¯** (æ ¸å¿ƒå…³é”®)
- æ‰§è¡Œå®Œæ•´çš„åè®®æ¡æ‰‹
- éªŒè¯è®¤è¯ä¿¡æ¯æ­£ç¡®æ€§
- æ£€æµ‹åè®®çº§åˆ«çš„é”™è¯¯

#### **ç¬¬3å±‚: å®é™…æµé‡æµ‹è¯•** (çœŸå®å¯ç”¨æ€§)
- é€šè¿‡ä»£ç†å‘é€HTTP/HTTPSè¯·æ±‚
- æµ‹è¯•å¤šä¸ªç›®æ ‡ç½‘ç«™
- éªŒè¯æµé‡ç¡®å®é€šè¿‡ä»£ç†

#### **ç¬¬4å±‚: å‡ºå£éªŒè¯** (åœ°ç†ä½ç½®ç¡®è®¤)
- æ£€æµ‹çœŸå®å‡ºå£IPåœ°å€
- éªŒè¯åœ°ç†ä½ç½®æ˜¯å¦ç¬¦åˆé¢„æœŸ
- ç¡®è®¤IPæ²¡æœ‰è¢«å°ç¦

### **çŠ¶æ€è¯„ä¼°æ ‡å‡†**

```python
proxy_status_levels = {
    'fully_available': {
        'description': 'å®Œå…¨å¯ç”¨',
        'criteria': 'æ‰€æœ‰æ£€æµ‹é€šè¿‡ï¼Œå¯æ­£å¸¸ä½¿ç”¨',
        'color': 'green',
        'icon': 'ğŸŸ¢'
    },
    'unstable': {
        'description': 'ä¸ç¨³å®š', 
        'criteria': 'éƒ¨åˆ†æµé‡æµ‹è¯•å¤±è´¥ï¼Œå¯èƒ½ä¸ç¨³å®š',
        'color': 'yellow',
        'icon': 'ğŸŸ¡'
    },
    'protocol_error': {
        'description': 'åè®®é”™è¯¯',
        'criteria': 'è®¤è¯å¤±è´¥ï¼Œé…ç½®å¯èƒ½æœ‰è¯¯',
        'color': 'orange', 
        'icon': 'ğŸŸ '
    },
    'traffic_blocked': {
        'description': 'æµé‡è¢«é˜»æ–­',
        'criteria': 'è¿æ¥æˆåŠŸä½†HTTPæµé‡æ— æ³•é€šè¿‡',
        'color': 'red',
        'icon': 'ğŸ”´'
    },
    'wrong_region': {
        'description': 'åœ°ç†ä½ç½®é”™è¯¯',
        'criteria': 'å·¥ä½œæ­£å¸¸ä½†å‡ºå£IPä¸åœ¨é¢„æœŸåœ°åŒº',
        'color': 'purple',
        'icon': 'ğŸŸ£'
    },
    'offline': {
        'description': 'ç¦»çº¿',
        'criteria': 'æ— æ³•å»ºç«‹åŸºç¡€è¿æ¥',
        'color': 'gray',
        'icon': 'âš«'
    }
}
```

## ğŸ“Š **ç›‘æ§æŒ‡æ ‡**

### **å¢å¼ºçš„ç›‘æ§æŒ‡æ ‡**

| æŒ‡æ ‡ç±»å‹ | æŒ‡æ ‡åç§° | å•ä½ | è¯´æ˜ |
|----------|----------|------|------|
| **å¯ç”¨æ€§** | èŠ‚ç‚¹çŠ¶æ€ | online/offline/error | å½“å‰è¿æ¥çŠ¶æ€ |
| **å¯ç”¨æ€§** | å¯ç”¨ç‡ | % | 24å°æ—¶å†…åœ¨çº¿æ—¶é—´ç™¾åˆ†æ¯” |
| **æ€§èƒ½** | å¹³å‡å»¶è¿Ÿ | ms | 5æ¬¡æµ‹è¯•çš„å¹³å‡å“åº”æ—¶é—´ |
| **æ€§èƒ½** | ä¸‹è½½é€Ÿåº¦ | Mbps | 1MB/10MBæ–‡ä»¶ä¸‹è½½é€Ÿåº¦ |
| **æ€§èƒ½** | è¿æ¥æˆåŠŸç‡ | % | è¿æ¥å°è¯•æˆåŠŸçš„ç™¾åˆ†æ¯” |
| **åœ°ç†** | èŠ‚ç‚¹ä½ç½® | å›½å®¶/åŸå¸‚ | é€šè¿‡IPåœ°ç†ä½ç½®æ£€æµ‹ |
| **ç½‘ç»œ** | ISPä¿¡æ¯ | æ–‡æœ¬ | äº’è”ç½‘æœåŠ¡æä¾›å•† |

### **ç›‘æ§é¢‘ç‡é…ç½®**
```yaml
monitoring_config:
  intervals:
    fast_check: 30s      # å¿«é€Ÿè¿é€šæ€§æ£€æŸ¥
    performance: 5m      # æ€§èƒ½æµ‹è¯•
    geo_update: 24h      # åœ°ç†ä¿¡æ¯æ›´æ–°
    cleanup: 1h          # æ•°æ®æ¸…ç†
  
  timeouts:
    connection: 10s      # è¿æ¥è¶…æ—¶
    performance: 30s     # æ€§èƒ½æµ‹è¯•è¶…æ—¶
    total_test: 60s      # å•èŠ‚ç‚¹æ€»æµ‹è¯•è¶…æ—¶
  
  retention:
    real_time: 1h        # å®æ—¶æ•°æ®ä¿ç•™
    hourly: 7d           # å°æ—¶çº§æ•°æ®ä¿ç•™
    daily: 30d           # æ—¥çº§æ•°æ®ä¿ç•™
```

---

## ğŸ’» **å®ç°æ–¹æ¡ˆ**

### **åç«¯ç›‘æ§æœåŠ¡**

#### **ä¸»ç›‘æ§æœåŠ¡**
```python
#!/usr/bin/env python3
# services/node-monitor.py

import asyncio
import json
import time
from typing import Dict, List
from dataclasses import dataclass
from datetime import datetime, timedelta

@dataclass
class MonitoringConfig:
    check_interval: int = 30
    performance_interval: int = 300
    max_concurrent: int = 10
    timeout: int = 10

class NodeMonitorService:
    def __init__(self, config: MonitoringConfig):
        self.config = config
        self.discovery = NodeDiscovery()
        self.tester = ConnectionTester()
        self.perf_tester = PerformanceTester()
        self.storage = MonitoringStorage()
        self.alerting = AlertingService()
        
        self.nodes = {}
        self.running = False
    
    async def start(self):
        """å¯åŠ¨ç›‘æ§æœåŠ¡"""
        print("ğŸš€ å¯åŠ¨ä»£ç†èŠ‚ç‚¹ç›‘æ§æœåŠ¡")
        
        # å‘ç°èŠ‚ç‚¹
        discovered_nodes = self.discovery.discover_nodes()
        print(f"ğŸ“¡ å‘ç° {len(discovered_nodes)} ä¸ªä»£ç†èŠ‚ç‚¹")
        
        for node in discovered_nodes:
            self.nodes[node.name] = node
        
        self.running = True
        
        # å¯åŠ¨ç›‘æ§ä»»åŠ¡
        await asyncio.gather(
            self._connection_monitor(),
            self._performance_monitor(),
            self._cleanup_task(),
            self._alerting_task()
        )
    
    async def _connection_monitor(self):
        """è¿æ¥çŠ¶æ€ç›‘æ§å¾ªç¯"""
        while self.running:
            print(f"ğŸ” å¼€å§‹è¿æ¥æ£€æŸ¥ - {datetime.now()}")
            
            # å¹¶å‘æµ‹è¯•æ‰€æœ‰èŠ‚ç‚¹
            semaphore = asyncio.Semaphore(self.config.max_concurrent)
            tasks = []
            
            for node in self.nodes.values():
                task = self._test_node_with_semaphore(semaphore, node)
                tasks.append(task)
            
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # å¤„ç†ç»“æœ
            for result in results:
                if isinstance(result, Exception):
                    print(f"âŒ æµ‹è¯•å‡ºé”™: {result}")
                    continue
                
                await self.storage.store_connection_result(result)
                
                # æ£€æŸ¥çŠ¶æ€å˜åŒ–
                await self._check_status_change(result)
            
            print(f"âœ… è¿æ¥æ£€æŸ¥å®Œæˆï¼Œç­‰å¾… {self.config.check_interval} ç§’")
            await asyncio.sleep(self.config.check_interval)
    
    async def _test_node_with_semaphore(self, semaphore, node):
        """å¸¦ä¿¡å·é‡çš„èŠ‚ç‚¹æµ‹è¯•"""
        async with semaphore:
            return await self.tester.test_connection(node)
    
    async def _performance_monitor(self):
        """æ€§èƒ½ç›‘æ§å¾ªç¯"""
        while self.running:
            await asyncio.sleep(self.config.performance_interval)
            
            print(f"ğŸ“Š å¼€å§‹æ€§èƒ½æµ‹è¯• - {datetime.now()}")
            
            # åªå¯¹åœ¨çº¿èŠ‚ç‚¹è¿›è¡Œæ€§èƒ½æµ‹è¯•
            online_nodes = await self._get_online_nodes()
            
            for node in online_nodes:
                try:
                    perf_result = await self.perf_tester.test_performance(node)
                    await self.storage.store_performance_result(perf_result)
                except Exception as e:
                    print(f"âŒ æ€§èƒ½æµ‹è¯•å¤±è´¥ {node.name}: {e}")
    
    async def _check_status_change(self, result: ConnectionResult):
        """æ£€æŸ¥èŠ‚ç‚¹çŠ¶æ€å˜åŒ–å¹¶è§¦å‘å‘Šè­¦"""
        previous_status = await self.storage.get_previous_status(result.node_name)
        
        if previous_status != result.status:
            await self.alerting.handle_status_change(
                node_name=result.node_name,
                old_status=previous_status,
                new_status=result.status,
                result=result
            )
    
    def stop(self):
        """åœæ­¢ç›‘æ§æœåŠ¡"""
        print("ğŸ›‘ åœæ­¢ç›‘æ§æœåŠ¡")
        self.running = False

# æœåŠ¡å¯åŠ¨è„šæœ¬
async def main():
    config = MonitoringConfig(
        check_interval=30,
        performance_interval=300,
        max_concurrent=5
    )
    
    monitor = NodeMonitorService(config)
    
    try:
        await monitor.start()
    except KeyboardInterrupt:
        monitor.stop()
        print("ğŸ‘‹ ç›‘æ§æœåŠ¡å·²åœæ­¢")

if __name__ == "__main__":
    asyncio.run(main())
```

#### **æ•°æ®å­˜å‚¨å±‚**
```python
# services/storage.py

import sqlite3
import redis
import json
from datetime import datetime, timedelta
from typing import Optional, List, Dict

class MonitoringStorage:
    def __init__(self):
        # Redisç”¨äºå®æ—¶æ•°æ®å’Œç¼“å­˜
        self.redis = redis.Redis(host='localhost', port=6379, db=0)
        
        # SQLiteç”¨äºå†å²æ•°æ®
        self.db_path = "data/monitoring.db"
        self._init_database()
    
    def _init_database(self):
        """åˆå§‹åŒ–æ•°æ®åº“è¡¨"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # è¿æ¥æµ‹è¯•ç»“æœè¡¨
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS connection_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                node_name TEXT NOT NULL,
                status TEXT NOT NULL,
                latency REAL,
                error TEXT,
                timestamp REAL NOT NULL,
                test_duration REAL
            )
        ''')
        
        # æ€§èƒ½æµ‹è¯•ç»“æœè¡¨
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS performance_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                node_name TEXT NOT NULL,
                avg_latency REAL,
                min_latency REAL,
                max_latency REAL,
                download_speed_1mb REAL,
                download_speed_10mb REAL,
                success_rate REAL,
                timestamp REAL NOT NULL
            )
        ''')
        
        # åˆ›å»ºç´¢å¼•
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_connection_node_time ON connection_results(node_name, timestamp)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_performance_node_time ON performance_results(node_name, timestamp)')
        
        conn.commit()
        conn.close()
    
    async def store_connection_result(self, result: ConnectionResult):
        """å­˜å‚¨è¿æ¥æµ‹è¯•ç»“æœ"""
        # å­˜å‚¨åˆ°Redis (å®æ—¶æ•°æ®)
        redis_key = f"node_status:{result.node_name}"
        self.redis.hset(redis_key, mapping={
            'status': result.status,
            'latency': result.latency or 0,
            'error': result.error or '',
            'timestamp': result.timestamp,
            'last_update': datetime.now().isoformat()
        })
        self.redis.expire(redis_key, 3600)  # 1å°æ—¶è¿‡æœŸ
        
        # å­˜å‚¨åˆ°SQLite (å†å²æ•°æ®)
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO connection_results 
            (node_name, status, latency, error, timestamp, test_duration)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (
            result.node_name,
            result.status,
            result.latency,
            result.error,
            result.timestamp,
            result.test_duration
        ))
        conn.commit()
        conn.close()
    
    async def get_node_status_summary(self) -> Dict:
        """è·å–æ‰€æœ‰èŠ‚ç‚¹çŠ¶æ€æ‘˜è¦"""
        summary = {}
        
        # ä»Redisè·å–å®æ—¶çŠ¶æ€
        for key in self.redis.scan_iter(match="node_status:*"):
            node_name = key.decode().split(":")[1]
            status_data = self.redis.hgetall(key)
            
            summary[node_name] = {
                'status': status_data[b'status'].decode(),
                'latency': float(status_data[b'latency']),
                'error': status_data[b'error'].decode(),
                'last_update': status_data[b'last_update'].decode()
            }
        
        return summary
    
    async def get_node_history(self, node_name: str, hours: int = 24) -> List[Dict]:
        """è·å–èŠ‚ç‚¹å†å²æ•°æ®"""
        since_time = time.time() - (hours * 3600)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT status, latency, timestamp, error
            FROM connection_results 
            WHERE node_name = ? AND timestamp > ?
            ORDER BY timestamp DESC
            LIMIT 1000
        ''', (node_name, since_time))
        
        results = []
        for row in cursor.fetchall():
            results.append({
                'status': row[0],
                'latency': row[1],
                'timestamp': row[2],
                'error': row[3]
            })
        
        conn.close()
        return results
    
    async def calculate_availability(self, node_name: str, hours: int = 24) -> float:
        """è®¡ç®—èŠ‚ç‚¹å¯ç”¨ç‡"""
        history = await self.get_node_history(node_name, hours)
        
        if not history:
            return 0.0
        
        online_count = sum(1 for record in history if record['status'] == 'online')
        return (online_count / len(history)) * 100
```

---

## ğŸ¨ **çœ‹æ¿è®¾è®¡**

### **ä¸»çœ‹æ¿ç•Œé¢**

#### **Reactç»„ä»¶ç»“æ„**
```jsx
// components/MonitoringDashboard.jsx

import React, { useState, useEffect } from 'react';
import { Card, Grid, Typography, Chip, LinearProgress } from '@mui/material';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';

const MonitoringDashboard = () => {
    const [nodes, setNodes] = useState([]);
    const [selectedNode, setSelectedNode] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        // WebSocketè¿æ¥ç”¨äºå®æ—¶æ›´æ–°
        const ws = new WebSocket('ws://localhost:8089/monitoring');
        
        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'node_status_update') {
                setNodes(data.nodes);
                setLoading(false);
            }
        };

        // åˆå§‹æ•°æ®åŠ è½½
        fetchNodesStatus();
        
        return () => ws.close();
    }, []);

    const fetchNodesStatus = async () => {
        try {
            const response = await fetch('/api/monitoring/nodes');
            const data = await response.json();
            setNodes(data.nodes);
        } catch (error) {
            console.error('è·å–èŠ‚ç‚¹çŠ¶æ€å¤±è´¥:', error);
        }
    };

    const getStatusColor = (status) => {
        switch (status) {
            case 'online': return 'success';
            case 'offline': return 'error';
            case 'error': return 'warning';
            default: return 'default';
        }
    };

    const getStatusIcon = (status) => {
        switch (status) {
            case 'online': return 'ğŸŸ¢';
            case 'offline': return 'ğŸ”´';
            case 'error': return 'ğŸŸ¡';
            default: return 'âšª';
        }
    };

    if (loading) {
        return <LinearProgress />;
    }

    return (
        <div className="monitoring-dashboard">
            <Typography variant="h4" gutterBottom>
                ğŸŒ ä»£ç†èŠ‚ç‚¹ç›‘æ§çœ‹æ¿
            </Typography>
            
            {/* æ¦‚è§ˆç»Ÿè®¡ */}
            <Grid container spacing={3} style={{ marginBottom: '20px' }}>
                <Grid item xs={12} md={3}>
                    <Card className="stat-card">
                        <Typography variant="h6">æ€»èŠ‚ç‚¹æ•°</Typography>
                        <Typography variant="h3">{nodes.length}</Typography>
                    </Card>
                </Grid>
                <Grid item xs={12} md={3}>
                    <Card className="stat-card">
                        <Typography variant="h6">åœ¨çº¿èŠ‚ç‚¹</Typography>
                        <Typography variant="h3" color="success.main">
                            {nodes.filter(n => n.status === 'online').length}
                        </Typography>
                    </Card>
                </Grid>
                <Grid item xs={12} md={3}>
                    <Card className="stat-card">
                        <Typography variant="h6">ç¦»çº¿èŠ‚ç‚¹</Typography>
                        <Typography variant="h3" color="error.main">
                            {nodes.filter(n => n.status === 'offline').length}
                        </Typography>
                    </Card>
                </Grid>
                <Grid item xs={12} md={3}>
                    <Card className="stat-card">
                        <Typography variant="h6">å¹³å‡å»¶è¿Ÿ</Typography>
                        <Typography variant="h3">
                            {Math.round(nodes.reduce((sum, n) => sum + (n.latency || 0), 0) / nodes.length)}ms
                        </Typography>
                    </Card>
                </Grid>
            </Grid>

            {/* èŠ‚ç‚¹åˆ—è¡¨ */}
            <Grid container spacing={2}>
                {nodes.map((node) => (
                    <Grid item xs={12} md={6} lg={4} key={node.name}>
                        <Card 
                            className="node-card"
                            onClick={() => setSelectedNode(node)}
                            style={{ cursor: 'pointer' }}
                        >
                            <div className="node-header">
                                <Typography variant="h6">
                                    {getStatusIcon(node.status)} {node.name}
                                </Typography>
                                <Chip 
                                    label={node.status.toUpperCase()} 
                                    color={getStatusColor(node.status)}
                                    size="small"
                                />
                            </div>
                            
                            <div className="node-details">
                                <Typography variant="body2" color="textSecondary">
                                    åè®®: {node.protocol.toUpperCase()}
                                </Typography>
                                <Typography variant="body2" color="textSecondary">
                                    æœåŠ¡å™¨: {node.server}
                                </Typography>
                                {node.status === 'online' && (
                                    <>
                                        <Typography variant="body2">
                                            å»¶è¿Ÿ: {node.latency}ms
                                        </Typography>
                                        <Typography variant="body2">
                                            å¯ç”¨ç‡: {node.availability}%
                                        </Typography>
                                    </>
                                )}
                                {node.error && (
                                    <Typography variant="body2" color="error">
                                        é”™è¯¯: {node.error}
                                    </Typography>
                                )}
                            </div>
                            
                            <div className="node-footer">
                                <Typography variant="caption">
                                    ä¸Šæ¬¡æ›´æ–°: {new Date(node.last_update).toLocaleTimeString()}
                                </Typography>
                            </div>
                        </Card>
                    </Grid>
                ))}
            </Grid>

            {/* èŠ‚ç‚¹è¯¦æƒ…å¼¹çª— */}
            {selectedNode && (
                <NodeDetailModal 
                    node={selectedNode}
                    onClose={() => setSelectedNode(null)}
                />
            )}
        </div>
    );
};

// èŠ‚ç‚¹è¯¦æƒ…ç»„ä»¶
const NodeDetailModal = ({ node, onClose }) => {
    const [history, setHistory] = useState([]);

    useEffect(() => {
        fetchNodeHistory();
    }, [node]);

    const fetchNodeHistory = async () => {
        try {
            const response = await fetch(`/api/monitoring/nodes/${node.name}/history`);
            const data = await response.json();
            setHistory(data.history);
        } catch (error) {
            console.error('è·å–å†å²æ•°æ®å¤±è´¥:', error);
        }
    };

    return (
        <div className="modal-overlay" onClick={onClose}>
            <div className="modal-content" onClick={e => e.stopPropagation()}>
                <Typography variant="h5" gutterBottom>
                    {node.name} è¯¦ç»†ä¿¡æ¯
                </Typography>
                
                {/* å»¶è¿Ÿè¶‹åŠ¿å›¾ */}
                <Card style={{ margin: '20px 0' }}>
                    <Typography variant="h6" style={{ padding: '16px' }}>
                        å»¶è¿Ÿè¶‹åŠ¿ (24å°æ—¶)
                    </Typography>
                    <ResponsiveContainer width="100%" height={300}>
                        <LineChart data={history}>
                            <CartesianGrid strokeDasharray="3 3" />
                            <XAxis 
                                dataKey="timestamp" 
                                tickFormatter={(value) => new Date(value * 1000).toLocaleTimeString()}
                            />
                            <YAxis />
                            <Tooltip 
                                labelFormatter={(value) => new Date(value * 1000).toLocaleString()}
                            />
                            <Line 
                                type="monotone" 
                                dataKey="latency" 
                                stroke="#8884d8" 
                                strokeWidth={2}
                                dot={false}
                            />
                        </LineChart>
                    </ResponsiveContainer>
                </Card>

                <button onClick={onClose}>å…³é—­</button>
            </div>
        </div>
    );
};

export default MonitoringDashboard;
```

#### **CSSæ ·å¼**
```css
/* styles/monitoring-dashboard.css */

.monitoring-dashboard {
    padding: 20px;
    background-color: #f5f5f5;
    min-height: 100vh;
}

.stat-card {
    padding: 20px;
    text-align: center;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 12px;
}

.node-card {
    padding: 16px;
    margin-bottom: 16px;
    border-radius: 8px;
    transition: all 0.3s ease;
    border-left: 4px solid transparent;
}

.node-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
}

.node-card[data-status="online"] {
    border-left-color: #4caf50;
}

.node-card[data-status="offline"] {
    border-left-color: #f44336;
}

.node-card[data-status="error"] {
    border-left-color: #ff9800;
}

.node-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
}

.node-details {
    margin: 12px 0;
}

.node-footer {
    border-top: 1px solid #eee;
    padding-top: 8px;
    margin-top: 12px;
}

.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0,0,0,0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.modal-content {
    background: white;
    border-radius: 8px;
    padding: 24px;
    max-width: 800px;
    width: 90%;
    max-height: 80%;
    overflow-y: auto;
}

/* å“åº”å¼è®¾è®¡ */
@media (max-width: 768px) {
    .monitoring-dashboard {
        padding: 10px;
    }
    
    .node-card {
        margin-bottom: 8px;
    }
    
    .modal-content {
        width: 95%;
        padding: 16px;
    }
}
```

---

## ğŸš€ **éƒ¨ç½²æŒ‡å—**

### **Dockeréƒ¨ç½²**

#### **Docker Composeé…ç½®**
```yaml
# compose.monitoring.yml
version: '3.8'

services:
  # æ·»åŠ åˆ°ç°æœ‰çš„clashæœåŠ¡
  node-monitor:
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile.node-monitor
    environment:
      - REDIS_URL=redis://redis:6379/0
      - SQLITE_PATH=/data/monitoring.db
      - CHECK_INTERVAL=30
      - PERFORMANCE_INTERVAL=300
    volumes:
      - ./.env:/app/.env:ro
      - ./data:/data
    depends_on:
      - redis
      - clash
    networks:
      - clash-network
    restart: unless-stopped

  # Redisç”¨äºç¼“å­˜
  redis:
    image: redis:7-alpine
    volumes:
      - redis-data:/data
    networks:
      - clash-network
    restart: unless-stopped

  # ç›‘æ§Webç•Œé¢
  monitoring-web:
    build:
      context: ./web/monitoring
      dockerfile: Dockerfile
    ports:
      - "8089:80"
    environment:
      - API_BASE_URL=http://node-monitor:8080
    depends_on:
      - node-monitor
    networks:
      - clash-network
    restart: unless-stopped

volumes:
  redis-data:

networks:
  clash-network:
    external: true
```

#### **ç›‘æ§æœåŠ¡Dockerfile**
```dockerfile
# dockerfiles/Dockerfile.node-monitor
FROM python:3.11-slim

WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

# å®‰è£…Pythonä¾èµ–
COPY requirements-monitoring.txt .
RUN pip install --no-cache-dir -r requirements-monitoring.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY services/ ./services/
COPY scripts/ ./scripts/

# åˆ›å»ºæ•°æ®ç›®å½•
RUN mkdir -p /data

# å¯åŠ¨è„šæœ¬
COPY docker-entrypoint-monitor.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

EXPOSE 8080

ENTRYPOINT ["/entrypoint.sh"]
CMD ["python", "services/node-monitor.py"]
```

### **å¯åŠ¨æ­¥éª¤**

#### **1. å®‰è£…ä¾èµ–**
```bash
# Pythonä¾èµ–
cat > requirements-monitoring.txt << 'EOF'
asyncio==3.4.3
aiohttp==3.8.4
redis==4.5.4
websockets==11.0.3
pyyaml==6.0
requests==2.31.0
geoip2==4.6.0
fastapi==0.100.0
uvicorn==0.22.0
python-multipart==0.0.6
EOF

pip install -r requirements-monitoring.txt
```

#### **2. å¯åŠ¨ç›‘æ§æœåŠ¡**
```bash
# å¯åŠ¨å®Œæ•´çš„ç›‘æ§ç³»ç»Ÿ
docker compose -f compose.yml -f compose.monitoring.yml up -d

# æŸ¥çœ‹ç›‘æ§æœåŠ¡æ—¥å¿—
docker compose logs -f node-monitor

# æ£€æŸ¥æœåŠ¡çŠ¶æ€
docker compose ps
```

#### **3. è®¿é—®ç›‘æ§çœ‹æ¿**
```bash
# Webç•Œé¢
open http://localhost:8089

# APIæ¥å£
curl http://localhost:8089/api/monitoring/nodes

# WebSocketå®æ—¶æ•°æ®
wscat -c ws://localhost:8089/monitoring
```

---

## ğŸ”Œ **APIæ¥å£**

### **RESTful API**
```python
# api/monitoring_api.py
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
import json

app = FastAPI(title="ä»£ç†èŠ‚ç‚¹ç›‘æ§API", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/api/monitoring/nodes")
async def get_nodes_status():
    """è·å–æ‰€æœ‰èŠ‚ç‚¹çŠ¶æ€"""
    storage = MonitoringStorage()
    summary = await storage.get_node_status_summary()
    
    return {
        "nodes": [
            {
                "name": name,
                "status": data["status"],
                "latency": data["latency"],
                "error": data["error"],
                "last_update": data["last_update"],
                "protocol": "unknown",  # éœ€è¦ä»é…ç½®è·å–
                "server": "unknown"     # éœ€è¦ä»é…ç½®è·å–
            }
            for name, data in summary.items()
        ],
        "total": len(summary),
        "online": len([d for d in summary.values() if d["status"] == "online"]),
        "timestamp": time.time()
    }

@app.get("/api/monitoring/nodes/{node_name}")
async def get_node_detail(node_name: str):
    """è·å–å•ä¸ªèŠ‚ç‚¹è¯¦ç»†ä¿¡æ¯"""
    storage = MonitoringStorage()
    
    # å½“å‰çŠ¶æ€
    summary = await storage.get_node_status_summary()
    if node_name not in summary:
        raise HTTPException(status_code=404, detail="èŠ‚ç‚¹ä¸å­˜åœ¨")
    
    # å†å²æ•°æ®
    history = await storage.get_node_history(node_name, hours=24)
    
    # å¯ç”¨ç‡
    availability = await storage.calculate_availability(node_name, hours=24)
    
    return {
        "name": node_name,
        "current_status": summary[node_name],
        "history": history,
        "availability": availability,
        "stats": {
            "total_tests": len(history),
            "successful_tests": len([h for h in history if h["status"] == "online"]),
            "avg_latency": sum(h["latency"] or 0 for h in history) / len(history) if history else 0
        }
    }

@app.get("/api/monitoring/nodes/{node_name}/history")
async def get_node_history(node_name: str, hours: int = 24):
    """è·å–èŠ‚ç‚¹å†å²æ•°æ®"""
    storage = MonitoringStorage()
    history = await storage.get_node_history(node_name, hours)
    
    return {
        "node_name": node_name,
        "history": history,
        "period_hours": hours
    }

# WebSocketç”¨äºå®æ—¶æ›´æ–°
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            try:
                await connection.send_text(message)
            except:
                # è¿æ¥å·²æ–­å¼€ï¼Œç§»é™¤
                self.active_connections.remove(connection)

manager = ConnectionManager()

@app.websocket("/monitoring")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            # å®šæœŸå‘é€çŠ¶æ€æ›´æ–°
            await asyncio.sleep(5)
            
            storage = MonitoringStorage()
            nodes_status = await storage.get_node_status_summary()
            
            message = {
                "type": "node_status_update",
                "nodes": [
                    {
                        "name": name,
                        **data
                    }
                    for name, data in nodes_status.items()
                ],
                "timestamp": time.time()
            }
            
            await websocket.send_text(json.dumps(message))
            
    except WebSocketDisconnect:
        manager.disconnect(websocket)
```

---

## âš¡ **æ€§èƒ½ä¼˜åŒ–**

### **ç›‘æ§æ€§èƒ½ä¼˜åŒ–**
```python
# å¹¶å‘ä¼˜åŒ–
class OptimizedMonitor:
    def __init__(self):
        self.connection_pool = aiohttp.ClientSession(
            connector=aiohttp.TCPConnector(
                limit=100,  # æœ€å¤§è¿æ¥æ•°
                limit_per_host=10,  # æ¯ä¸ªä¸»æœºæœ€å¤§è¿æ¥æ•°
                ttl_dns_cache=300,  # DNSç¼“å­˜
                use_dns_cache=True
            ),
            timeout=aiohttp.ClientTimeout(total=30)
        )
    
    async def batch_test_nodes(self, nodes: List[ProxyNode]) -> List[ConnectionResult]:
        """æ‰¹é‡æµ‹è¯•èŠ‚ç‚¹ - ä¼˜åŒ–ç‰ˆ"""
        # åˆ†æ‰¹å¤„ç†ï¼Œé¿å…è¿‡è½½
        batch_size = 10
        results = []
        
        for i in range(0, len(nodes), batch_size):
            batch = nodes[i:i + batch_size]
            batch_results = await asyncio.gather(
                *[self.test_node(node) for node in batch],
                return_exceptions=True
            )
            results.extend(batch_results)
            
            # æ‰¹æ¬¡é—´ç¨ä½œåœé¡¿
            await asyncio.sleep(0.5)
        
        return results
```

### **æ•°æ®å­˜å‚¨ä¼˜åŒ–**
```python
# æ‰¹é‡å†™å…¥ä¼˜åŒ–
class OptimizedStorage:
    def __init__(self):
        self.write_buffer = []
        self.buffer_size = 100
        self.last_flush = time.time()
    
    async def store_result_batch(self, result: ConnectionResult):
        """æ‰¹é‡å­˜å‚¨ç»“æœ"""
        self.write_buffer.append(result)
        
        # ç¼“å†²åŒºæ»¡æˆ–è¶…æ—¶åˆ™å†™å…¥
        if (len(self.write_buffer) >= self.buffer_size or 
            time.time() - self.last_flush > 60):
            await self._flush_buffer()
    
    async def _flush_buffer(self):
        """åˆ·æ–°ç¼“å†²åŒºåˆ°æ•°æ®åº“"""
        if not self.write_buffer:
            return
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # æ‰¹é‡æ’å…¥
        cursor.executemany('''
            INSERT INTO connection_results 
            (node_name, status, latency, error, timestamp, test_duration)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', [
            (r.node_name, r.status, r.latency, r.error, r.timestamp, r.test_duration)
            for r in self.write_buffer
        ])
        
        conn.commit()
        conn.close()
        
        self.write_buffer.clear()
        self.last_flush = time.time()
```

### **å‰ç«¯æ€§èƒ½ä¼˜åŒ–**
```jsx
// è™šæ‹ŸåŒ–é•¿åˆ—è¡¨
import { FixedSizeList as List } from 'react-window';

const VirtualizedNodeList = ({ nodes }) => {
    const Row = ({ index, style }) => (
        <div style={style}>
            <NodeCard node={nodes[index]} />
        </div>
    );

    return (
        <List
            height={600}
            itemCount={nodes.length}
            itemSize={120}
            width="100%"
        >
            {Row}
        </List>
    );
};

// æ•°æ®ç¼“å­˜
const useNodesData = () => {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
        const fetchData = async () => {
            try {
                // æ£€æŸ¥ç¼“å­˜
                const cached = localStorage.getItem('nodes_data');
                if (cached) {
                    const parsedCache = JSON.parse(cached);
                    if (Date.now() - parsedCache.timestamp < 30000) {
                        setData(parsedCache.data);
                        setLoading(false);
                        return;
                    }
                }
                
                // è·å–æ–°æ•°æ®
                const response = await fetch('/api/monitoring/nodes');
                const newData = await response.json();
                
                // æ›´æ–°ç¼“å­˜
                localStorage.setItem('nodes_data', JSON.stringify({
                    data: newData,
                    timestamp: Date.now()
                }));
                
                setData(newData);
            } catch (error) {
                console.error('Error fetching data:', error);
            } finally {
                setLoading(false);
            }
        };
        
        fetchData();
        const interval = setInterval(fetchData, 30000);
        return () => clearInterval(interval);
    }, []);
    
    return { data, loading };
};
```

---

## ğŸ“‹ **æ€»ç»“**

è¿™ä¸ªä»£ç†èŠ‚ç‚¹ç›‘æ§ä¸å¯ç”¨æ€§çœ‹æ¿ç³»ç»Ÿæä¾›äº†ï¼š

### **æ ¸å¿ƒä»·å€¼**
âœ… **å®æ—¶ç›‘æ§**: 30ç§’é—´éš”æ£€æµ‹æ‰€æœ‰ä»£ç†èŠ‚ç‚¹çŠ¶æ€  
âœ… **å¤šåè®®æ”¯æŒ**: è¦†ç›–ä¸»æµä»£ç†åè®®  
âœ… **å¯è§†åŒ–çœ‹æ¿**: ç›´è§‚çš„Webç•Œé¢å±•ç¤º  
âœ… **æ€§èƒ½åˆ†æ**: å»¶è¿Ÿã€é€Ÿåº¦ã€å¯ç”¨ç‡ç­‰å…³é”®æŒ‡æ ‡  
âœ… **æ™ºèƒ½å‘Šè­¦**: è‡ªåŠ¨æ•…éšœæ£€æµ‹å’Œé€šçŸ¥  

### **æŠ€æœ¯ç‰¹ç‚¹**
- **é«˜æ€§èƒ½**: å¼‚æ­¥å¹¶å‘æµ‹è¯•ï¼Œæ”¯æŒå¤§é‡èŠ‚ç‚¹
- **å¯æ‰©å±•**: æ¨¡å—åŒ–è®¾è®¡ï¼Œæ˜“äºæ·»åŠ æ–°åè®®
- **å®æ—¶æ€§**: WebSocketæ¨é€ï¼Œç§’çº§çŠ¶æ€æ›´æ–°
- **å¯é æ€§**: æ•°æ®æŒä¹…åŒ–ï¼Œæ•…éšœæ¢å¤æœºåˆ¶

### **Vibe Codingå¼€å‘æ—¶é—´**
- **åç«¯ç›‘æ§æœåŠ¡**: 8-10å°æ—¶
- **å‰ç«¯çœ‹æ¿ç•Œé¢**: 6-8å°æ—¶  
- **éƒ¨ç½²é…ç½®**: 2-3å°æ—¶
- **æµ‹è¯•è°ƒä¼˜**: 2-3å°æ—¶
- **æ€»è®¡**: 18-24å°æ—¶

è¿™ä¸ªæ–¹æ¡ˆå®Œå…¨å¯ä»¥å®ç°ä½ æåˆ°çš„éœ€æ±‚ï¼Œé€šè¿‡æœ¬æœºè®¿é—®å„ç§æ ¼å¼çš„ä»£ç†è¿›è¡Œå‘¨æœŸæ€§æ£€æµ‹ï¼Œå¹¶æä¾›ç¾è§‚å®ç”¨çš„çŠ¶æ€çœ‹æ¿ã€‚

---

**æ›´æ–°æ—¥æœŸ**: 2025-07-13  
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**ç»´æŠ¤è€…**: ä»£ç†ç›‘æ§å¼€å‘å›¢é˜Ÿ